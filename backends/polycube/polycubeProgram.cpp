/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <chrono>
#include <ctime>

#include "polycubeProgram.h"
#include "polycubeType.h"
#include "polycubeControl.h"
#include "polycubeParser.h"
#include "polycubeTable.h"
#include "frontends/p4/coreLibrary.h"
#include "frontends/common/options.h"

#define FORWARD_ACTION_ENUM_NAME "forward_action"

namespace POLYCUBE {

bool PolycubeProgram::build() {
    auto pack = toplevel->getMain();
    if (pack->type->name != "polycubeFilter")
        ::warning(ErrorType::WARN_INVALID, "%1%: the main polycube package should be called polycubeFilter"
                  "; are you using the wrong architecture?", pack->type->name);

    if (pack->getConstructorParameters()->size() != 2) {
        ::error("Expected toplevel package %1% to have 2 parameters", pack->type);
        return false;
    }

    auto pb = pack->getParameterValue(model.filter.parser.name)
                      ->to<IR::ParserBlock>();
    BUG_CHECK(pb != nullptr, "No parser block found");
    parser = new PolycubeParser(this, pb, typeMap);
    bool success = parser->build();
    if (!success)
        return success;

    auto cb = pack->getParameterValue(model.filter.filter.name)
                      ->to<IR::ControlBlock>();
    BUG_CHECK(cb != nullptr, "No control block found");
    control = new PolycubeControl(this, cb, parser->headers);
    success = control->build();
    if (!success)
        return success;

    return true;
}

void PolycubeProgram::emitC(CodeBuilder* builder) {
    builder->target->emitIncludes(builder);
    builder->newline();
    emitPreamble(builder);
    control->emitTableInstances(builder);
    builder->newline();
    builder->emitIndent();
    builder->target->emitCodeSection(builder, functionName);
    builder->emitIndent();
    builder->target->emitMain(builder, functionName, model.CPacketName.str());
    builder->blockStart();
    builder->emitIndent();

    emitHeaderInstances(builder);
    builder->endOfStatement(true);

    emitLocalVariables(builder);
    builder->newline();
    builder->emitIndent();
    builder->appendFormat("goto %s;", IR::ParserState::start.c_str());
    builder->newline();

    parser->emit(builder);
    emitPipeline(builder);

    builder->emitIndent();
    builder->appendFormat("%s: return RX_DROP;\n", endLabel.c_str());
    builder->blockEnd(true);  // end of function
}

void PolycubeProgram::emitGeneratedComment(CodeBuilder* builder) {
    std::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();
    std::time_t time = std::chrono::system_clock::to_time_t(now);
    builder->append("/* Automatically generated by ");
    builder->append(options.exe_name);
    builder->append(" from ");
    builder->append(options.file);
    builder->append(" on ");
    builder->append(std::ctime(&time));
    builder->append(" */");
    builder->newline();
}

void PolycubeProgram::emitH(CodeBuilder* builder, cstring) {
    emitGeneratedComment(builder);
    builder->appendLine("#ifndef _P4_GEN_HEADER_");
    builder->appendLine("#define _P4_GEN_HEADER_");
    builder->target->emitIncludes(builder);
    builder->appendFormat("#define MAP_PATH \"%s\"", builder->target->sysMapPath().c_str());
    builder->newline();
    emitTypes(builder);
    control->emitTableTypes(builder);
    builder->appendLine("#if CONTROL_PLANE");
    builder->appendLine("static void init_tables() ");
    builder->blockStart();
    builder->emitIndent();
    builder->appendFormat("u32 %s = 0;", zeroKey.c_str());
    builder->newline();
    control->emitTableInitializers(builder);
    builder->blockEnd(true);
    builder->appendLine("#endif");
    builder->appendLine("#endif");
}

void PolycubeProgram::emitTypes(CodeBuilder* builder) {
    for (auto d : program->objects) {
        if (d->is<IR::Type>() && !d->is<IR::IContainer>() &&
            !d->is<IR::Type_Extern>() && !d->is<IR::Type_Parser>() &&
            !d->is<IR::Type_Control>() && !d->is<IR::Type_Typedef>() &&
            !d->is<IR::Type_Error>()) {
            auto type = PolycubeTypeFactory::instance->create(d->to<IR::Type>());
            if (type == nullptr
                || type->type->getP4Type()->toString() == PolycubeControl::packetTypeName
                || type->type->getP4Type()->toString() == PolycubeControl::metadataTypeName)
                continue;
            type->emit(builder);
            builder->newline();
        }
    }
}

void PolycubeProgram::emitPreamble(CodeBuilder* builder) {
    emitTypes(builder);
}

void PolycubeProgram::emitLocalVariables(CodeBuilder* builder) {
    builder->emitIndent();
    builder->appendFormat("void* %s = %s;",
                          packetStartVar.c_str(),
                          builder->target->dataOffset(model.CPacketName.str()).c_str());
    builder->newline();
    builder->emitIndent();
    builder->appendFormat("void* %s = %s;",
                          packetEndVar.c_str(),
                          builder->target->dataEnd(model.CPacketName.str()).c_str());
    builder->newline();
}

void PolycubeProgram::emitHeaderInstances(CodeBuilder* builder) {
    parser->headerType->declare(builder, parser->headers->name.name, false);
    builder->appendFormat(" = {}");
}

void PolycubeProgram::emitPipeline(CodeBuilder* builder) {
    builder->emitIndent();
    builder->append(IR::ParserState::accept);
    builder->append(":");
    builder->newline();
    builder->emitIndent();
    builder->blockStart();
    builder->emitIndent();
    control->emit(builder);
    builder->blockEnd(true);
}

}  // namespace EBPF
